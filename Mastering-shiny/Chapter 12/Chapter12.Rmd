---
title: "Chapter12 - Tidy evaluation"
output: html_notebook
---

```{r setup}
knitr::opts_chunk$set(eval = FALSE)
```


```{r}
library(shiny)

library(dplyr, warn.conflicts = FALSE)
library(ggplot2)
```

# 12.1 Data-masking

using `data-variable` names instead of using `env-name$data-variable-name`.(like dplyr and withr )


```{r}
filter(diamonds, x == 0 | y == 0)
diamonds[diamonds$x == 0 | diamonds$y == 0, ]
```


## 12.1.1 Indirection

```{r}
min_carat <- 1
diamonds %>% filter(carat > min_carat)
```

```{r}
var <- "carat"
min <- 1
diamonds[diamonds[[var]] > min, ]
```

```{r}
var <- "carat"
diamonds %>% filter(.data[[var]] > min)
```

put it to an shiny app:

```{r}
ui <- fluidPage(
  selectInput("var", "Variable", choices = names(diamonds)),
  numericInput("min", "Minimum", value = 1),
  tableOutput("output")
)
server <- function(input, output, session) {
  data <- reactive(filter(diamonds, .data[[input$var]] > input$min))
  output$output <- renderTable(head(data()))
}
shinyApp(ui, server)
```



Note that if we didn’t use `.data`, as below, the app will not work correctly, but also won’t generate an error message. That’s because `input$var` will be a string like `"carat"` and `"carat" > 0` is valid R expression that evaluates to `TRUE`, selecting all rows.

```{r}
server <- function(input, output, session) {
  data <- reactive(filter(diamonds, input$var > input$min))
  output$output <- renderTable(head(data()))
}
shinyApp(ui, server)
```


## 12.1.2 Example: ggplot2

```{r}
ui <- fluidPage(
  selectInput("x", "X variable", choices = names(iris)),
  selectInput("y", "Y variable", choices = names(iris)),
  plotOutput("plot")
)
server <- function(input, output, session) {
  output$plot <- renderPlot({
    ggplot(iris, aes(.data[[input$x]], .data[[input$y]])) +
      geom_point(position = ggforce::position_auto())
  }, res = 96)
}
shinyApp(ui, server)
```

adding optional `geom`:

```{r}
ui <- fluidPage(
  selectInput("x", "X variable", choices = names(iris)),
  selectInput("y", "Y variable", choices = names(iris)),
  selectInput("geom", "geom", c("point", "smooth", "jitter")),
  plotOutput("plot")
)
server <- function(input, output, session) {
  plot_geom <- reactive({
    switch(input$geom,
      point = geom_point(),
      smooth = geom_smooth(se = FALSE),
      jitter = geom_jitter()
    )
  })
  
  output$plot <- renderPlot({
    ggplot(iris, aes(.data[[input$x]], .data[[input$y]])) +
      plot_geom()
  }, res = 96)
}
shinyApp(ui, server)
```

## 12.1.3 Example: dplyr

```{r}
ui <- fluidPage(
  selectInput("var", "Select variable", choices = names(mtcars)),
  sliderInput("min", "Minimum value", 0, min = 0, max = 100),
  selectInput("sort", "Sort by", choices = names(mtcars)),
  tableOutput("data")
)
server <- function(input, output, session) {
  observeEvent(input$var, {
    rng <- range(mtcars[[input$var]])
    updateSliderInput(
      session, "min", 
      value = rng[[1]], 
      min = rng[[1]], 
      max = rng[[2]]
    )
  })
  
  output$data <- renderTable({
    mtcars %>% 
      filter(.data[[input$var]] > input$min) %>% 
      arrange(.data[[input$sort]])
  })
}
shinyApp(ui, server)
```


```{r}
ui <- fluidPage(
  selectInput("var", "Sort by", choices = names(mtcars)),
  checkboxInput("desc", "Descending order?"),
  tableOutput("data")
)
server <- function(input, output, session) {
  sorted <- reactive({
    if (input$desc) {
      arrange(mtcars, desc(.data[[input$var]]))
    } else {
      arrange(mtcars, .data[[input$var]])
    }
  })
  output$data <- renderTable(sorted())
}
shinyApp(ui, server)
```
1

## 12.1.4 User supplied data

```{r}
ui <- fluidPage(
  fileInput("data", "dataset", accept = ".tsv"),
  selectInput("var", "var", character()),
  numericInput("min", "min", 1, min = 0, step = 1),
  tableOutput("output")
)
server <- function(input, output, session) {
  data <- reactive({
    req(input$data)
    vroom::vroom(input$data$datapath)
  })
  observeEvent(data(), {
    updateSelectInput(session, "var", choices = names(data()))
  })
  observeEvent(input$var, {
    val <- data()[[input$var]]
    updateNumericInput(session, "min", value = min(val))
  })
  
  output$output <- renderTable({
    req(input$var)
    
    data() %>% 
      filter(.data[[input$var]] > input$min) %>% 
      arrange(.data[[input$var]]) %>% 
      head(10)
  })
}
shinyApp(ui, server)
```



```{r}
df <- data.frame(x = 1, y = 2, input = 3)
df %>% filter(.data[[input$var]] > input$min)

df$input$min
```
```{r}
df %>% filter(.data[[input$var]] > .env$input$min)
```

Note that you only need to worry about this problem when working with user supplied data.


## 12.1.5 Why not use base R?

```{r}
df[df[[input$var]] > input$min, ]
```

* You’ll need `drop = FALSE` if `df` only contains a single column (otherwise you’ll get a vector instead of a data frame).

* You’ll need to use `which()` or similar to drop any missing values.

* You can’t do group-wise filtering (e.g. filter(df, n() == 1)).


# 12.2 Tidy-selection

## 12.2.1 Indirection
```{r}
ui <- fluidPage(
  selectInput("vars", "Variables", names(mtcars), multiple = TRUE),
  tableOutput("data")
)

server <- function(input, output, session) {
  output$data <- renderTable({
    req(input$vars)
    mtcars %>% select(all_of(input$vars))
  })
}
shinyApp(ui, server)
```


## 12.2.2 Tidy-selection and data-masking


```{r}
ui <- fluidPage(
  selectInput("vars", "Variables", names(mtcars), multiple = TRUE),
  tableOutput("count")
)

server <- function(input, output, session) {
  output$count <- renderTable({
    req(input$vars)
    
    mtcars %>% 
      group_by(across(all_of(input$vars))) %>% 
      summarise(n = n())
  })
}
shinyApp(ui, server)
```



```{r}
ui <- fluidPage(
  selectInput("vars_g", "Group by", names(mtcars), multiple = TRUE),
  selectInput("vars_s", "Summarise", names(mtcars), multiple = TRUE),
  tableOutput("data")
)

server <- function(input, output, session) {
  output$data <- renderTable({
    mtcars %>% 
      group_by(across(all_of(input$vars_g))) %>% 
      summarise(across(all_of(input$vars_s), mean), n = n())
  })
}
shinyApp(ui, server)
```

